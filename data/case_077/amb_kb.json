{
  "ambiguities": [
    {
      "id": "1_O1_2016_athletics_walk_spacing",
      "kind": "Operation boundary",
      "node_id": "clean_medals",
      "op": "project",
      "source_text": "Replace the word \"kilometres\" in Events with an \"km\" abbreviation",
      "ref": "    df_medals.loc[\n        (df_medals['Year'] == 2016) & (df_medals['Sport'] == 'Athletics') & (\n            df_medals['Event'].str.contains(r'^20km walk$', regex=True)),\n        'Event'\n    ] = '20 km walk'\n    df_medals.loc[\n        (df_medals['Year'] == 2016) & (df_medals['Sport'] == 'Athletics') & (\n            df_medals['Event'].str.contains(r'^50km walk$', regex=True)),\n        'Event'\n    ] = '50 km walk'"
    },
    {
      "id": "2_C1_discipline_deterministic_renames",
      "kind": "Row-level concept",
      "node_id": "clean_medals_discipline",
      "op": "project",
      "source_text": "Group together sensible Disciplines",
      "ref": "    df_medals['Discipline'] = df_medals['Discipline'].replace({\n        'Wrestling Gre-R': 'Greco-Roman',\n        'Gre-Roman': 'Greco-Roman',\n        'Modern Pentathalon ': 'Modern Pentathalon',\n        'Modern Pentath.': 'Modern Pentathalon',\n        'Modern Pentath': 'Modern Pentathalon',\n        'Modern pentathlon': 'Modern Pentathalon',\n        'Synchronized S.': 'Synchronized Swimming',\n        'Synchronized swimming': 'Synchronized Swimming',\n        'synchronized swimming': 'Synchronized Swimming',\n        'Beach volley.': 'Beach volleyball',\n        'Mountain biking': 'Mountain Bike',\n        'Artistic': 'Artistic G.',\n        'Artistic Gymnastics': 'Artistic G.',\n        'Rhythmic': 'Rhythmic G.',\n        'Rhythmic Gymnastics': 'Rhythmic G.'\n    })"
    },
    {
      "id": "3_C1_cycling_discipline_to_cycling_track",
      "kind": "Row-level concept",
      "node_id": "clean_medals_discipline",
      "op": "project",
      "source_text": "Group together sensible Disciplines",
      "ref": "    df_medals.loc[\n        (df_medals['Sport'] == 'Cycling') & (\n            df_medals['Discipline'].str.lower().isin(['track cycling', 'cycling track'])),\n        'Discipline'\n    ] = 'Cycling Track'\n    df_medals.loc[\n        (df_medals['Sport'] == 'Cycling') & (\n            df_medals['Discipline'].str.lower().isin(['road cycling', 'cycling road'])),\n        'Discipline'\n    ] = 'Cycling Track'\n    df_medals.loc[(df_medals['Sport'] == 'Cycling') & (\n        df_medals['Year'] <= 1992), 'Discipline'] = 'Cycling Track'"
    },
    {
      "id": "4_C2_event_medal_uniqueness_ck_exclude_discipline",
      "kind": "Group-level concept",
      "node_id": "dedup_ck",
      "op": "dedup",
      "source_text": "Aggregate to a row for each Event medal (i.e. we know longer need the Athlete names Level of Detail)",
      "ref": "df_ck = df_medals_for_agg[is_ck].drop_duplicates(\n        subset=['Country', 'Year', 'Medal', 'Event', 'Sport', 'Event_Gender']\n    )"
    },
    {
      "id": "5_C2_event_medal_uniqueness_non_ck_include_discipline",
      "kind": "Group-level concept",
      "node_id": "dedup_non_ck",
      "op": "dedup",
      "source_text": "Aggregate to a row for each Event medal (i.e. we know longer need the Athlete names Level of Detail)",
      "ref": "df_non_ck = df_medals_for_agg[~is_ck].drop_duplicates(\n        subset=['Country', 'Year', 'Medal', 'Event',\n                'Sport', 'Event_Gender', 'Discipline']\n    )"
    },
    {
      "id": "6_O2_drop_medals_still_missing_country_or_code",
      "kind": "Operation incomplete",
      "node_id": "f_medals_nonempty",
      "op": "filter",
      "source_text": "Make sure every medal has both a Country and Country Code associated with it",
      "ref": "    df_medals = df_medals[(df_medals['Country'] != '') & (\n        df_medals['Country Code'] != '')].copy()"
    },
    {
      "id": "7_O2_fill_missing_country_code_from_country_name",
      "kind": "Operation incomplete",
      "node_id": "p_fill_code",
      "op": "project",
      "source_text": "Make sure every medal has both a Country and Country Code associated with it",
      "ref": "def fill_code_from_country(row):\n        if pd.isna(row['Country Code']) or row['Country Code'] == '':\n            country = row['Country']\n            if country in country_to_code:\n                return country_to_code[country]\n        return row['Country Code']\n\n    df_medals['Country Code'] = df_medals.apply(fill_code_from_country, axis=1)"
    },
    {
      "id": "8_O2_fill_missing_country_name_from_country_code",
      "kind": "Operation incomplete",
      "node_id": "p_fill_country",
      "op": "project",
      "source_text": "Make sure every medal has both a Country and Country Code associated with it",
      "ref": "def fill_country_from_code(row):\n        if pd.isna(row['Country']) or row['Country'] == '':\n            code = row['Country Code']\n            if code in code_to_country:\n                return code_to_country[code]\n        return row['Country']\n\n    df_medals['Country'] = df_medals.apply(fill_country_from_code, axis=1)"
    },
    {
      "id": "9_C1_host_city_country_split_rule",
      "kind": "Row-level concept",
      "node_id": "p_hosts_city_country_extract",
      "op": "project",
      "source_text": "Using the Hosts dataset, create a field for the Host Country",
      "ref": "    def extract_host_info(host_str):\n        host_str = str(host_str).strip('\"').strip().replace('\\xa0', ' ')\n        parts = host_str.split(',', 1)\n        if len(parts) == 2:\n            return parts[0].strip(), parts[1].strip()\n        else:\n            return host_str, ''\n\n    host_info = df_output02['Host'].apply(lambda x: extract_host_info(x))\n    df_output02['Host City'] = host_info.apply(lambda x: x[0])\n    df_output02['Host Country'] = host_info.apply(lambda x: x[1])"
    },
    {
      "id": "11_C2_hosts_year_derived_from_start_date",
      "kind": "Row-level concept",
      "node_id": "p_hosts_year",
      "op": "project",
      "intent": "Derive Year for hosts from the standardized Start Date field.",
      "ref": "def year_from_ddmmyyyy(s: str):\n        return int(s.split('/')[-1]) if isinstance(s, str) and s else None\n    df_output02['Year'] = df_output02['Start Date'].apply(year_from_ddmmyyyy)"
    },
    {
      "id": "12_O1_output01_zero_counts_as_blank",
      "kind": "Operation incomplete",
      "node_id": "p_out01_zero_to_na",
      "op": "project",
      "source_text": "Create a table showing total Gold, Silver and Bronze medals from each country for each year",
      "ref": "for col in ['Gold', 'Silver', 'Bronze']:\n        df_output01[col] = df_output01[col].apply(\n            lambda x: '' if pd.isna(x) else int(x)\n        )"
    }
  ]
}