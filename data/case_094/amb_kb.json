{
  "ambiguities": [
    {
      "id": "1_O3_remaining_gate_priority",
      "kind": "Row-level concept",
      "node_id": "assign_book",
      "op": "script",
      "source_text": "Remaining flights should assigned to gates with the highest transport times to remote stands",
      "ref": "    \"remaining\": lambda f: sorted(\n            f.accessible_gates, key=lambda g: (-remote_time_map[g], g)\n        ),\n"
    },
    {
      "id": "2_O2_include_unassigned_time_slots_in_output",
      "kind": "Operation incomplete",
      "node_id": "assign_gates",
      "op": "script",
      "intent": "Include availability time slots with no assigned flight in the output as blank/null fields.",
      "ref": "    records = [\n        {\n            \"Gate\": gate,\n            \"Stand\": entry.get(\"Stand\") if entry else pd.NA,\n            \"Date\": slot,\n            \"Flight\": entry.get(\"Flight\") if entry else pd.NA,\n            \"Requires Bus?\": entry.get(\"Requires Bus?\") if entry else pd.NA,\n            \"Time to Reach Stand\": entry.get(\"Time to Reach Stand\") if entry else pd.NA,\n        }\n        for gate in sorted(gate_slots)\n        for slot, entry in sorted(gate_slots[gate].items())\n    ]\n"
    },
    {
      "id": "3_O3_remote_gate_priority",
      "kind": "Row-level concept",
      "node_id": "assign_remote",
      "op": "script",
      "source_text": "Flights at remote stands should be assigned next, to minimise bus transport times for passengers",
      "ref": "    \"remote\": lambda f: sorted(\n            f.accessible_gates, key=lambda g: (remote_time_map[g], g)\n        ),\n"
    },
    {
      "id": "4_O2_availability_as_source_of_truth",
      "kind": "Single-table reference",
      "node_id": "assign_setup",
      "op": "script",
      "intent": "Use the Gate Availability dataset as the source of truth for which (Gate, DateTime slot) combinations exist and can be booked.",
      "ref": "    gate_slots: Dict[int, Dict[pd.Timestamp, dict]] = {\n        gate: {date: {} for date in group[\"Date\"]}\n        for gate, group in availability_df.groupby(\"Gate\")\n    }\n"
    },
    {
      "id": "5_O3_flight_processing_order",
      "kind": "Row-level concept",
      "node_id": "assign_setup",
      "op": "script",
      "source_text": "For any ties that we encounter, lower flight numbers should have priority",
      "ref": "    flights.sort(key=lambda f: (\n        order_by_category[_category(f)], f.start, f.flight_no))\n"
    },
    {
      "id": "6_O2_default_date_for_boarding_time",
      "kind": "Row-level concept",
      "node_id": "parse_allocations",
      "op": "project",
      "source_text": "In the Stand Allocations dataset, create a date time field for when boarding begins",
      "ref": "def _parse_time_value(value: int | str) -> pd.Timestamp:\n    \"\"\"Convert integer like 600 into a timestamp on 2020-02-01.\"\"\"\n\n    value_str = str(value).zfill(4)\n    hour = int(value_str[:2])\n    minute = int(value_str[2:])\n    return pd.Timestamp(2020, 2, 1, hour, minute)\n"
    }
  ]
}