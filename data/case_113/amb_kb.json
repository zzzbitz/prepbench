{
  "ambiguities": [
    {
      "id": "1_C1_economy_only_for_o1_o2",
      "kind": "Row-level concept",
      "node_id": "econ_only",
      "op": "filter",
      "intent": "Restrict outputs 1 and 2 calculations to Economy passengers only.",
      "ref": "df_ps_econ = df_ps[df_ps[\"Business Class\"] == \"Economy\"].copy()"
    },
    {
      "id": "2_O1_time_of_day_boundary_inclusive_18",
      "kind": "Operation boundary",
      "node_id": "flight_clean",
      "op": "project",
      "source_text": "Morning - Before 12:00\nAfternoon - Between 12:00 - 18:00\nEvening - After 18:00",
      "ref": "if h < 12:\n            return \"Morning\"\n        if 12 <= h <= 18:\n            return \"Afternoon\"\n        return \"Evening\""
    },
    {
      "id": "3_D1_flight_details_header_from_first_bracket_row",
      "kind": "Single-table reference",
      "node_id": "flight_parse",
      "op": "project",
      "source_text": "Parse the Flight Details so that they are in separate fields",
      "ref": "lines = p3.read_text(encoding=\"utf-8\").strip().splitlines()\n            if cols is None:\n                cols = parts\n            else:\n                rows.append(parts)\ndf_f = pd.DataFrame(rows, columns=cols)"
    },
    {
      "id": "4_D2_ps_join_on_passenger_number",
      "kind": "Multi-table alignment",
      "node_id": "join_ps",
      "op": "join",
      "source_text": "Combine the Seat List and Passenger List tables.",
      "ref": "df_ps = df_pass.merge(seat_long, on=\"passenger_number\", how=\"left\")"
    },
    {
      "id": "5_O2_ps_left_join_keep_unseated_passengers",
      "kind": "Operation incomplete",
      "node_id": "join_ps",
      "op": "join",
      "source_text": "Combine the Seat List and Passenger List tables.",
      "ref": "df_ps = df_pass.merge(seat_long, on=\"passenger_number\", how=\"left\")"
    },
    {
      "id": "6_C2_o1_per_flight_totals_before_averaging",
      "kind": "Group-level concept",
      "node_id": "o1_flight_totals",
      "op": "aggregate",
      "source_text": "We want to take a look at the average for the flights within each time period.",
      "ref": "flight_totals = df_ps_econ.groupby(\"flight_number\", as_index=False)[\n        \"purchase_amount\"].sum().rename(columns={\"purchase_amount\": \"total_purchase\"})"
    },
    {
      "id": "7_C2_o1_rank_starts_at_1",
      "kind": "Row-level concept",
      "node_id": "o1_rank",
      "op": "project",
      "intent": "Assign Rank values starting at 1 for output_01.",
      "ref": "avg_per_flight.insert(0, \"Rank\", range(1, len(avg_per_flight) + 1))"
    },
    {
      "id": "8_O1_o1_round_avg_per_flight_2dp",
      "kind": "Operation boundary",
      "node_id": "o1_round",
      "op": "project",
      "intent": "Round output_01 Avg per Flight to 2 decimal places.",
      "ref": "avg_per_flight[\"Avg per Flight\"] = avg_per_flight[\"Avg per Flight\"].round(\n        2)"
    },
    {
      "id": "9_C2_o1_rank_descending_by_avg",
      "kind": "Row-level concept",
      "node_id": "o1_sort",
      "op": "sort",
      "intent": "Rank output_01 with highest Avg per Flight as Rank = 1 (descending by Avg per Flight).",
      "ref": "avg_per_flight = avg_per_flight.sort_values([\"Avg per Flight\", \"Depart Time of Day\"], ascending=[\n                                                False, True], kind=\"mergesort\").reset_index(drop=True)"
    },
    {
      "id": "10_O3_o1_tiebreak_depart_time_of_day_asc",
      "kind": "Operation boundary",
      "node_id": "o1_sort",
      "op": "sort",
      "intent": "Break ties in output_01 by Depart Time of Day ascending.",
      "ref": "avg_per_flight = avg_per_flight.sort_values([\"Avg per Flight\", \"Depart Time of Day\"], ascending=[\n                                                False, True], kind=\"mergesort\").reset_index(drop=True)"
    },
    {
      "id": "11_C2_o2_rank_starts_at_1",
      "kind": "Row-level concept",
      "node_id": "o2_rank",
      "op": "project",
      "intent": "Assign Rank values starting at 1 for output_02.",
      "ref": "seat_totals.insert(0, \"Rank\", range(1, len(seat_totals) + 1))"
    },
    {
      "id": "12_O1_o2_round_purchase_amount_2dp",
      "kind": "Operation boundary",
      "node_id": "o2_round",
      "op": "project",
      "intent": "Round output_02 Purchase Amount to 2 decimal places.",
      "ref": "seat_totals[\"Purchase Amount\"] = seat_totals[\"Purchase Amount\"].round(2)"
    },
    {
      "id": "13_C2_o2_rank_descending_by_purchase_amount",
      "kind": "Row-level concept",
      "node_id": "o2_sort",
      "op": "sort",
      "intent": "Rank output_02 with highest Purchase Amount as Rank = 1 (descending by Purchase Amount).",
      "ref": "seat_totals = seat_totals.sort_values([\"Purchase Amount\", \"Seat Position\"], ascending=[\n                                          False, True], kind=\"mergesort\").reset_index(drop=True)"
    },
    {
      "id": "14_O3_o2_tiebreak_seat_position_asc",
      "kind": "Operation boundary",
      "node_id": "o2_sort",
      "op": "sort",
      "intent": "Break ties in output_02 by Seat Position ascending.",
      "ref": "seat_totals = seat_totals.sort_values([\"Purchase Amount\", \"Seat Position\"], ascending=[\n                                          False, True], kind=\"mergesort\").reset_index(drop=True)"
    },
    {
      "id": "15_C2_o2_sum_purchase_by_seat_position",
      "kind": "Group-level concept",
      "node_id": "o2_totals",
      "op": "aggregate",
      "source_text": "What seat position had the highest purchase amount?",
      "ref": "seat_totals = df_ps_econ.groupby(\"Seat Position\", as_index=False)[\n        \"purchase_amount\"].sum()"
    },
    {
      "id": "16_C2_o3_rank_starts_at_1",
      "kind": "Row-level concept",
      "node_id": "o3_rank",
      "op": "project",
      "intent": "Assign Rank values starting at 1 for output_03.",
      "ref": "class_totals.insert(0, \"Rank\", range(1, len(class_totals) + 1))"
    },
    {
      "id": "17_O1_o3_round_purchase_amount_2dp",
      "kind": "Operation boundary",
      "node_id": "o3_round",
      "op": "project",
      "intent": "Round output_03 Purchase Amount to 2 decimal places.",
      "ref": "class_totals[\"Purchase Amount\"] = class_totals[\"Purchase Amount\"].round(2)"
    },
    {
      "id": "18_C2_o3_rank_descending_by_purchase_amount",
      "kind": "Row-level concept",
      "node_id": "o3_sort",
      "op": "sort",
      "intent": "Rank output_03 with highest Purchase Amount as Rank = 1 (descending by Purchase Amount).",
      "ref": "class_totals = class_totals.sort_values([\"Purchase Amount\", \"Business Class\"], ascending=[\n                                            False, True], kind=\"mergesort\").reset_index(drop=True)"
    },
    {
      "id": "19_O3_o3_tiebreak_business_class_asc",
      "kind": "Operation boundary",
      "node_id": "o3_sort",
      "op": "sort",
      "intent": "Break ties in output_03 by Business Class ascending.",
      "ref": "class_totals = class_totals.sort_values([\"Purchase Amount\", \"Business Class\"], ascending=[\n                                            False, True], kind=\"mergesort\").reset_index(drop=True)"
    },
    {
      "id": "20_C2_o3_sum_purchase_grouped_by_class",
      "kind": "Group-level concept",
      "node_id": "o3_totals",
      "op": "aggregate",
      "source_text": "As Business Class purchases are free, how much is this costing us?",
      "ref": "class_totals = df_ps.groupby(\"Business Class\", as_index=False)[\n        \"purchase_amount\"].sum()"
    },
    {
      "id": "21_O2_drop_passengers_missing_required_ids",
      "kind": "Operation incomplete",
      "node_id": "pass_filter_valid",
      "op": "filter",
      "intent": "Drop passenger records missing passenger_number or flight_number before joining/aggregation.",
      "ref": "df_pass = df_pass.dropna(\n        subset=[\"passenger_number\", \"flight_number\"]).copy()"
    },
    {
      "id": "22_O2_bc_single_row_means_start_equals_end",
      "kind": "Operation boundary",
      "node_id": "plane_finalize",
      "op": "project",
      "intent": "If Plane Details Business Class is a single row number, treat it as a range with start=end.",
      "ref": "v = int(r)\n            return (v, v)"
    },
    {
      "id": "23_D1_plane_flight_identifier_is_flightno",
      "kind": "Single-table reference",
      "node_id": "plane_rename",
      "op": "project",
      "intent": "Use Plane Details column FlightNo. as the flight identifier (renamed to FlightID).",
      "ref": "df_plane = df_plane.rename(columns={\"FlightNo.\": \"FlightID\"})"
    },
    {
      "id": "24_O1_business_class_row_range_inclusive",
      "kind": "Operation boundary",
      "node_id": "ps_with_class",
      "op": "project",
      "intent": "Classify Business Class passengers using inclusive row bounds (Row >= bc_start and Row <= bc_end).",
      "ref": "is_bc = (df_ps[\"Row\"].notna()) & (df_ps[\"bc_start\"].notna()) & (\n        df_ps[\"Row\"] >= df_ps[\"bc_start\"]) & (df_ps[\"Row\"] <= df_ps[\"bc_end\"])"
    },
    {
      "id": "25_O2_drop_seat_assignments_missing_passenger_number",
      "kind": "Operation incomplete",
      "node_id": "seat_filter_valid",
      "op": "filter",
      "intent": "Retain only seat assignments that have a valid passenger_number.",
      "ref": "seat_long = seat_long.dropna(subset=[\"passenger_number\"]).copy()"
    },
    {
      "id": "26_D1_seat_list_wide_to_long_melt",
      "kind": "Single-table reference",
      "node_id": "seat_long",
      "op": "pivot",
      "source_text": "This includes the row number and seat letter within each row.",
      "ref": "seat_long = df_seat.melt(\n        id_vars=[\"Row\"], var_name=\"SeatLetter\", value_name=\"passenger_number\")"
    }
  ]
}